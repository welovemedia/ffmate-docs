---
url: /docs/getting-started.md
---
# ðŸš€ Getting Started

Setting up FFmate is quick and straightforward. Follow these steps to get up and running in no time.

## Download FFmate

Get the latest release of FFmate from [GitHub](https://github.com/welovemedia/ffmate/releases)

## Running FFmate

Once installed, start the FFmate server from the command line:

```sh
ffmate server
```

ðŸ’¡ Tip: Want to start FFmate with a convenient tray menu? Simply run:

```sh
ffmate server --tray
```

By default, the server runs on **<http://localhost:3000>**. Is port 3000 unavailable, or do you want to start FFmate on a different port? Learn how to change the port here ðŸ‘‰ [Learn more](#port-configuration).

## Submitting your first task

To submit a new transcoding task, make a `POST` request to the API:

```sh
curl -X POST http://localhost:3000/api/v1/tasks \
     -H "Content-Type: application/json" \
     -d '{
       "command": "-y -i ${INPUT_FILE} -c:v libx264 -preset fast -crf 23 ${OUTPUT_FILE}",
       "inputFile": "videos/input.mp4",
       "outputFile": "videos/output.mp4",
       "priority": 2
     }'
```

### Monitoring the Task

Check the status of your task by making a `GET` request:

```sh
curl http://localhost:3000/api/v1/tasks/{taskId}
```

Replace `{taskId}` with the actual ID returned when submitting the task.

You can  track your FFmate tasks directly in the Web UI. ðŸ‘‰ [Learn more](#web-ui-monitoring)

## Watchfolders

FFmate can automatically detect and process new files in a **watchfolder**.

To configure a watchfolder, make a `POST` request to the API:

```sh
curl -X POST http://localhost:3000/api/v1/watchfolders \
     -H "Content-Type: application/json" \
     -d '{
       "name": "My Watchfolder",
       "description": "Automatically processes new media files",
       "interval": 5,
       "growthChecks": 3,
       "preset": "preset-id",
       "path": "/path/to/watchfolder",
       "filter": {
         "extensions": {
           "include": ["mp4", "mov"],
           "exclude": ["tmp", "log"]
         }
       }
     }'
```

Once configured, any new file matching the criteria will be automatically processed when added to the watchfolder.

Are you more in the mood to configure your watchfolder in a more visual way? No problem! Learn how to configure your first watchfolder using our Web UI ðŸ‘‰ [Check it out](#web-ui)Â 

## Real-Time updates with Webhook notifications

FFmate can notify external systems about job progress, completion, or failures via **webhooks**.

To configure a webhook, make a `POST` request to the API:

```sh
curl --location 'http://localhost:3000/api/v1/webhooks' \
--header 'Content-Type: application/json' \
--data '{ "event": "task.created", "url": "https://myserver.com/ffmate/webhook.create" }'
```

FFmate will send a `POST` request to the specified URL when the  event occurs.

## Updating FFmate

Keeping FFmate up to date ensures you have the latest features, bug fixes, and performance improvements.

### Update FFmate via CLI

To update FFmate to the latest version, run the following command in your terminal:

```sh
ffmate update
```

This command will check for the latest release and install the update automatically.

### Verify the Installed Version

After updating, you can confirm that FFmate is running the latest version:

```sh
ffmate --version
```

---

---
url: /docs/swagger.md
---
# API Documentation with Swagger (OpenAPI)

`ffmate` provides comprehensive API documentation using the Swagger. This interactive documentation allows you to easily explore, understand, and test `ffmate`'s REST API directly from your web browser.

### How to Access the Swagger UI

Once your `ffmate` server is running, you can access the Swagger UI in your web browser at the following URL:

**`http://<your-ffmate-host>:<port>/swagger/index.html`**

* Replace `<your-ffmate-host>` with the hostname or IP address where `ffmate` is running (e.g., `localhost` if running locally).
* Replace `<port>` with the port number `ffmate` is listening on (default is `3000`).

**Default URL (if running locally on the default port):**
`http://localhost:3000/swagger/index.html`

---

---
url: /docs/flags.md
---
# Command-Line Flags and Options

The `ffmate` binary offers several command-line flags to customize its behavior when starting the server or performing other actions. These flags allow you to configure paths, ports, operational parameters, and debugging options.

You can typically see a list of available commands and their flags by running `ffmate --help` or `ffmate <command> --help`.

### Global Flags

These flags can usually be used with any `ffmate` command (like `server`, `update`, `reset`).

* **`-d, --debug <namespaces>`** or **`--debug="<namespaces>"`**
  * **Purpose:** Enables detailed debug logging for specific parts of the application. `ffmate` uses the `debugo` library for this.
  * **Value:** A comma-separated list of namespaces or wildcards.
    * `"*"`: Enables all debug messages.
    * `"gin"`: Enables debug messages specifically from the Gin web framework components.
    * `"queue"`: Enables debug messages from the task queue processing logic.
    * `"sev:webhook"`: Enables debug messages for webhook firing from the internal `sev` framework.
    * You can combine them: `"*,-gin"` (all except gin) or `"queue,ffmpeg"` (only queue and ffmpeg).
  * **Environment Variable:** Debug namespaces can also be set using the `DEBUGO` environment variable. If both are set, the command-line flag usually takes precedence.
  * **Default:** Debug logging is off by default.

### `server` Command Flags

These flags are specific to the `ffmate server` command, which starts the main `ffmate` application (API, Web UI, queue processor, etc.).

* **`-f, --ffmpeg <path>`** or **`--ffmpeg="<path>"`**
  * **Purpose:** Specifies the path to the `ffmpeg` executable.
  * **Value:** The full path to your `ffmpeg` binary.
  * **Default:** `ffmpeg` (assumes `ffmpeg` is in your system's `PATH`).
  * **Example:** `ffmate server --ffmpeg="/usr/local/bin/ffmpeg"`

* **`-p, --port <port_number>`** or **`--port="<port_number>"`**
  * **Purpose:** Sets the port number on which the `ffmate` server (API and Web UI) will listen.
  * **Value:** A valid port number.
  * **Default:** `3000`
  * **Example:** `ffmate server --port="8080"`

* **`-t, --tray`**
  * **Purpose:** Enables the system tray icon (experimental). When enabled, `ffmate` will show an icon in your system tray with status information and basic controls.
  * **Value:** Not applicable (flag is either present or absent).
  * **Default:** `false` (tray icon is disabled).
  * **Example:** `ffmate server --tray`

* **`-b, --database <path>`** or **`--database="<path>"`**
  * **Purpose:** Specifies the path to the SQLite database file where `ffmate` stores its data (tasks, presets, webhooks, etc.).
  * **Value:** A file path.
    * If prefixed with `~/` (e.g., `~/.ffmate/data.sqlite`), `~` will be expanded to your home directory.
  * **Default:** `~/.ffmate/db.sqlite`
  * **Example:** `ffmate server --database="/var/lib/ffmate/production.db"`

* **`-m, --max-concurrent-tasks <number>`** or **`--max-concurrent-tasks="<number>"`**
  * **Purpose:** Defines the maximum number of `ffmpeg` tasks that `ffmate` will run simultaneously.
  * **Value:** A positive integer.
  * **Default:** `3`
  * **Example:** `ffmate server --max-concurrent-tasks="5"` (allows up to 5 tasks to run at once)

* **`-s, --send-telemetry <true|false>`** or **`--send-telemetry=<true|false>`**
  * **Purpose:** Enables or disables the sending of anonymous usage telemetry data to `telemetry.ffmate.io`. This data helps the developers understand how `ffmate` is used and improve the product.
  * **Value:** `true` or `false`.
  * **Default:** `true` (telemetry is enabled).
  * **Example:** `ffmate server --send-telemetry=false`

### `update` Command Flags

These flags are specific to the `ffmate update` command, which checks for and applies updates to the `ffmate` binary itself.

* **`--dry`**
  * **Purpose:** Performs a "dry run" of the update check. It will report if an update is available but will not actually download or install it.
  * **Value:** Not applicable (flag is either present or absent).
  * **Default:** `false` (updates are applied if available).
  * **Example:** `ffmate update --dry`

### `reset` Command Flags

These flags are specific to the `ffmate reset` command, which is used to reset the status of any tasks that were marked as `RUNNING` to `DONE_CANCELED`. This can be useful if `ffmate` was shut down unexpectedly while tasks were in progress.

### How Flags are Processed

`ffmate` uses the Viper library for configuration management. This means that flag values can often be overridden by environment variables or configuration files if `ffmate` were set up to use them (though the provided code primarily focuses on flags and defaults). Command-line flags generally have the highest precedence.

### Example Usage

Starting the `ffmate` server with a custom port, a specific `ffmpeg` binary, and disabling telemetry:
`ffmate server --port="3030" --ffmpeg="/opt/custom_ffmpeg/bin/ffmpeg" --send-telemetry=false --debug="queue,api"`

Checking for updates without applying them:
`ffmate update --dry`

---

---
url: /docs/debugging.md
---
# Debugging

`FFmate` offers powerful, fine-grained debugging options that allow you to capture detailed debug information from specific internal components, making it easier to trace issues and understand whatâ€™s happening under the hood.

### Enabling Debug Mode

You can enable debug logging in two primary ways:

1. **Using the Command-Line Flag:**
   * The most common way is to use the global `-d` or `--debug` flag when running any `ffmate` command (especially `ffmate server`).
   * **Syntax:** `ffmate <command> --debug="<namespaces>"`
   * **Example:** `ffmate server --debug="*"`

2. **Using OS Environment Variable:**
   * You can set the environment variable before running `FFmate`.
   * **Syntax (Linux/macOS):** `DEBUGO="<namespaces>" ffmate server`
   * **Syntax (Windows PowerShell):** `$env:DEBUGO="<namespaces>"; ffmate server`
   * If both the flag and the environment variable are set, the command-line flag will take precedence.

### Understanding Namespaces

The core of `FFmate`'s debugging system is **namespaces**. When you enable debugging, you specify which namespaces you're interested in.

* **Wildcards:**
  * `*`: The asterisk acts as a wildcard, matching any sequence of characters.
    * `--debug="*"`: Enables **all** debug messages from every component. This is very verbose but useful for a general overview.
    * `--debug="sev:*"`: Enables all debug messages from components within the `sev` namespace (the internal framework).
    * `--debug="*ffmpeg*"`: Enables debug messages from any namespace containing "ffmpeg".
* **Exclusion:**
  * `-`: Prefixing a namespace with a hyphen excludes it.
  * `--debug="*,-gin"`: Enables all debug messages *except* those from the `gin` namespace.
  * `--debug="sev:*,-sev:metrics"`: Enables all `sev` messages except those specifically from `sev:metrics`.
* **Multiple Namespaces:**
  * You can specify multiple namespaces by separating them with commas.
  * `--debug="queue,ffmpeg,watchfolder"`: Enables debug messages only from the `queue`, `ffmpeg`, and `watchfolder` components.

### Debug Namespaces in FFmate

Below are some of the key namespaces used for debugging. They help generate detailed log output from specific components within `FFmate`:

* **`*` (Global Wildcard):**
  * **What to expect:** Extremely verbose output covering every debug message from all parts of `ffmate`, including internal framework (`sev`) operations, Gin request handling, database interactions (if enabled at that level), queue processing, webhook firing, etc.
  * **Use when:** You're unsure where a problem lies and need a broad overview, or when tracing a complex interaction across multiple components. Be prepared for a lot of output.

* **`gin`:**
  * **What to expect:** Logs related to the Gin web framework, such as incoming HTTP requests, route matching, and middleware execution. Useful for debugging API call issues.
  * **Example Log:** `gin [GIN] 2025/02/14 - 10:00:00 | 200 | 1.23ms | 127.0.0.1 | POST /api/v1/tasks`

* **`queue`:**
  * **What to expect:** Detailed logs about the task queue processor. This includes finding new tasks, task state transitions (e.g., moving from QUEUED to RUNNING), maximum concurrent task checks, and pre/post-processing script execution steps.
  * **Example Log:** `queue no queued tasks found` or `queue processing task (uuid: ...)` or `queue triggered preProcessing script (uuid: ...)`

* **`ffmpeg`:**
  * **What to expect:** Logs specifically from `ffmate`'s interaction with the `ffmpeg` binary. This primarily includes the real-time progress parsing from `ffmpeg`'s stderr. You'll see lines showing frame counts, FPS, bitrate, time, and speed. This namespace **does not** show the raw `ffmpeg` stderr itself (that's part of the main application log if an error occurs), but rather `ffmate`'s interpretation of it for progress.
  * **Example Log:** `ffmpeg progress: 25.50 {Frame:123 FPS:29.97 Bitrate:1500k Time:4.10 Speed:1.5x} (uuid: ...)`

* **`watchfolder`:**
  * **What to expect:** Information about the watchfolder processing, such as initialization, directory scanning, file state tracking (growth checks), and new task creation from watched files.
  * **Example Log:** `watchfolder initialized new watchfolder watcher (uuid: ...)` or `watchfolder created new task for watchfolder (uuid: ...) file: ...`

* **`sev:<component>` (Internal Framework):**
  * The `sev` namespace is for `ffmate`'s internal framework. You might use these for deeper debugging if you suspect an issue within the core application logic.
  * **`sev:webhook`**: Logs related to firing webhooks (e.g., "fired webhook for event 'task:created'").
  * **`sev:metrics`**: Logs about Prometheus metrics registration.
  * **`sev:controller`**: Logs related to controller registration.
  * **`sev:telemetry`**: Logs about sending telemetry data.
  * **`sev:middleware`**: Logs related to middleware registration or execution.

* **`websocket:controller` / `websocket:service`:**
  * **What to expect:** Logs related to WebSocket connections, disconnections, and messages being broadcast.
  * **Example Log:** `websocket:controller new connection from 127.0.0.1 (uuid: ...)`

* **`prometheus:register`:**
  * **What to expect:** Logs specifically detailing the registration of Prometheus metrics.
  * **Example Log:** `prometheus:register registered prometheus gauge 'task_created'`

### Setting debug from the API

`ffmate` provides API endpoints to change the debug namespaces *while the server is running*, without needing to restart it:

* **`PATCH /api/v1/debug/namespace/{namespaces}`**
  * **Purpose:** Sets the active debug namespaces.
  * **Example:** `curl -X PATCH http://localhost:3000/api/v1/debug/namespace/queue,ffmpeg`
* **`DELETE /api/v1/debug/namespace`**
  * **Purpose:** Turns off all debug logging (sets namespaces to empty).
  * **Example:** `curl -X DELETE http://localhost:3000/api/v1/debug/namespace`

This is extremely useful for enabling targeted debugging on a live system without disrupting its normal operation more than necessary.

Sure! Here's the improved version formatted in clean Markdown:

### Debug Message Format

All debug messages follow a consistent structure:

```
HH:MM:SS.mmm <NAMESPACE> <MESSAGE>
```

* **`HH:MM:SS.mmm`** â€“ Timestamp showing hours, minutes, seconds, and milliseconds
* **`<NAMESPACE>`** â€“ Identifies the component that generated the message
* **`<MESSAGE>`** â€“ The actual debug log content

**Example:**

```
10:05:15.123 queue processing task (uuid: abc-123-def-456)
```

---

---
url: /docs/wildcards.md
---
# Dynamic Wildcards

FFmate's dynamic wildcards are designed for smart, customizable file and directory naming.  Instead of tedious manual setup for each output, FFmate allows you to use placeholders. These placeholders provide a flexible method to dynamically generate both filenames and directory paths, as FFmate intelligently replaces them with actual data as it processes your tasks.  Essentially, placeholders deliver a simple yet efficient way to achieve truly dynamic and automated filename and directory naming within FFmate.

For example, you can include the **date, time, input file name, or a unique ID** in your output file names. This helps keep your files **organized, consistent, and easy to track**, without extra effort.

## Input & Output File Information

### Full File Path:

These wildcards return the **complete file path**, including the directory, filename, and extension.

| Wildcard         | Description                          | Example Output          |
|-----------------|----------------------------------|-------------------------|
| `${INPUT_FILE}`  | Full path of the input file      | `/source/input.mp4`     |
| `${OUTPUT_FILE}` | Full path of the output file     | `/destination/output.mp4`    |

#### Example:

```sh
curl -X POST http://localhost:3000/api/v1/tasks \
     -H "Content-Type: application/json" \
     -d '{
       "command": "-y -i ${INPUT_FILE} -c:v libx264 -preset fast -crf 23 ${OUTPUT_FILE}",
       "inputFile": "/volumes/ffmate/source/input.mp4",
       "outputFile": "/volumes/ffmate/destination/output.mp4"
     }'
```

### Filename Information:

These wildcards return the **filename** from the full path, either with or without the extension.

| Wildcard               | Description                                         | Example Output    |
|------------------------|-----------------------------------------------------|-------------------|
| `${INPUT_FILE_BASE}`   | Filename with extension (without the path)         | `input.mp4`      |
| `${OUTPUT_FILE_BASE}`  | Filename with extension (without the path)         | `output.mp4`     |
| `${INPUT_FILE_BASENAME}` | Filename without extension                        | `input`          |
| `${OUTPUT_FILE_BASENAME}` | Filename without extension                        | `output`         |

#### Example:

```sh
curl -X POST http://localhost:3000/api/v1/tasks \
     -H "Content-Type: application/json" \
     -d '{
       "command": "-y -i ${INPUT_FILE} -c:v libx264 -preset fast -crf 23 ${OUTPUT_FILE}.mkv",
       "inputFile": "/volumes/ffmate/videos/original_movie.mp4",
       "outputFile": "/volumes/ffmate/converted/${INPUT_FILE_BASENAME}"
     }'
```

#### Output Path:

```sh
/volumes/ffmate/converted/input.mkv
```

***

### File Extensions and Directory Path:

These wildcards return **the file extension** and the **directory path**.

| Wildcard                  | Description                               | Example Output    |
|---------------------------|-------------------------------------------|-------------------|
| `${INPUT_FILE_EXTENSION}` | File extension of the input file         | `.mp4`           |
| `${OUTPUT_FILE_EXTENSION}` | File extension of the output file        | `.mp4`           |
| `${INPUT_FILE_DIR}`       | Directory path of the input file         | `/source`        |
| `${OUTPUT_FILE_DIR}`      | Directory path of the output file        | `/destination`        |

#### Example:

```sh
curl -X POST http://localhost:3000/api/v1/tasks \
     -H "Content-Type: application/json" \
     -d '{
       "command": "-y -i ${INPUT_FILE} -c:v libx264 -preset fast -crf 23 ${OUTPUT_FILE}",
       "inputFile": "/volumes/ffmate/source/video.mp4",
       "outputFile": "/volumes/ffmate/destination/${INPUT_FILE_BASENAME}_converted${INPUT_FILE_EXTENSION}"
     }'
```

#### Output Path:

```sh
/volumes/ffmate/destination/input_converted.mp4
```

## Date & Time Wildcards

These wildcards insert **dynamic timestamps** into your output paths, making it easy to organize processed files based on date and time.

| Wildcard                   | Description                                | Example Output   |
|----------------------------|--------------------------------------------|------------------|
| `${DATE_YEAR}`             | Full year (4 digits)                      | `2024`           |
| `${DATE_SHORTYEAR}`        | Short year (last 2 digits)                | `24`             |
| `${DATE_MONTH}`            | Month number (01-12)                      | `01`             |
| `${DATE_DAY}`              | Day of the month (01-31)                   | `15`             |
| `${DATE_WEEK}`             | ISO week number (01-52)                   | `03`             |
| `${TIME_HOUR}`             | Hour (24-hour format, 00-23)              | `14`             |
| `${TIME_MINUTE}`           | Minute (00-59)                            | `05`             |
| `${TIME_SECOND}`           | Second (00-59)                            | `32`             |

#### Example:

```sh
curl -X POST http://localhost:3000/api/v1/tasks \
     -H "Content-Type: application/json" \
     -d '{
       "command": "-y -i ${INPUT_FILE} -c:v libx264 -preset fast -crf 23 ${OUTPUT_FILE}",
       "inputFile": "/volumes/ffmate/source/video.mp4",
       "outputFile": "/volumes/ffmate/destination/${DATE_YEAR}/${DATE_MONTH}/${DATE_DAY}/video_${TIME_HOUR}-${TIME_MINUTE}-${TIME_SECOND}.mp4",
       "priority": 2
     }'
```

#### Output Path:

```sh
/volumes/ffmate//destination/2024/02/15/video_14-30-45.mp4
```

## â³ Timestamps

These wildcards generate **precise timestamps** to create unique file and directory names based on the **current time**.

| Wildcard                      | Description                                | Example Output          |
|--------------------------------|--------------------------------------------|-------------------------|
| `${TIMESTAMP_SECONDS}`        | Unix timestamp in seconds                 | `1705318712`           |
| `${TIMESTAMP_MILLISECONDS}`   | Unix timestamp with milliseconds precision | `1705318712123`         |
| `${TIMESTAMP_MICROSECONDS}`   | Unix timestamp with microseconds precision | `1705318712123456`      |
| `${TIMESTAMP_NANOSECONDS}`    | Unix timestamp with nanoseconds precision  | `1705318712123456789`   |

#### Example:

```sh
curl -X POST http://localhost:3000/api/v1/tasks \
     -H "Content-Type: application/json" \
     -d '{
       "command": "-y -i ${INPUT_FILE} -c:v libx264 -preset fast -crf 23 ${OUTPUT_FILE}",
       "inputFile": "/volumes/ffmate/source/video.mp4",
       "outputFile": "/volumes/ffmate/destination/video_${TIMESTAMP_SECONDS}.mp4"
     }'
```

#### Output Path:

```sh
/volumes/ffmate/destination/video_1705318712.mp4
```

## System Information

These wildcards return **system information**, specifically the **operating system name** and **CPU architecture**.

| Wildcard       | Description                        | Example Output  |
|---------------|------------------------------------|----------------|
| `${OS_NAME}`  | Operating system name             | `linux`        |
| `${OS_ARCH}`  | CPU architecture                  | `amd64`        |

#### Example:

```sh
curl -X POST http://localhost:3000/api/v1/tasks \
     -H "Content-Type: application/json" \
     -d '{
       "command": "-y -i ${INPUT_FILE} -c:v libx264 -preset fast -crf 23 ${OUTPUT_FILE}",
       "inputFile": "/volumes/ffmate/source/video.mp4",
       "outputFile": "/volumes/ffmate/processed/${OS_NAME}/${OS_ARCH}/video.mp4"
     }'
```

#### Output Path:

```sh
/volumes/ffmate/processed/linux/amd64/video.mp4
```

## Unique Identifier

This wildcard generate **random unique identifiers**.

| Wildcard       | Description                        | Example Output                                  |
|---------------|------------------------------------|------------------------------------------------|
| `${UUID}`     | Randomly generated UUID (v4)      | `550e8400-e29b-41d4-a716-446655440000`        |

#### Example:

```sh
curl -X POST http://localhost:3000/api/v1/tasks \
     -H "Content-Type: application/json" \
     -d '{
       "command": "-y -i ${INPUT_FILE} -c:v libx264 -preset fast -crf 23 ${OUTPUT_FILE}",
       "inputFile": "/volumes/ffmate/source/video.mp4",
       "outputFile": "/volumes/ffmate/processed/${UUID}_video.mp4"
     }'
```

#### Output Path:

```sh
/volumes/ffmate/processed/550e8400-e29b-41d4-a716-446655440000_video.mp4
```

---

---
url: /docs/ffmate-internals.md
---
# FFmate Internals

This section provides a more in-depth look at some of `FFmate`'s key internal components and how they interact. Understanding these is key for advanced troubleshooting, fine-tuning configurations, and integrating ffmate into your workflows.

### High-Level Component Diagram

```mermaid
graph TD
    %% â”€â”€â”€ UI & API â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    WebUI["Web UI"]:::ui
    REST_API["REST API"]:::api
    WebUI --> REST_API

    %% â”€â”€â”€ Services (single row) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    subgraph Services ["Services"]
        direction LR
        TaskSvc["Task Service"]:::svc
        PresetSvc["Preset Service"]:::svc
        WatchfolderSvc["Watchfolder Service"]:::svc
        WebhookSvc["Webhook Service"]:::svc
    end
    REST_API --> TaskSvc
    REST_API --> PresetSvc
    REST_API --> WatchfolderSvc
    REST_API --> WebhookSvc

    %% â”€â”€â”€ Core & DB side-by-side â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    subgraph Core ["Core"]
        direction LR
        FFMate["FFmate"]:::core
        DB[(SQLite DB)]:::db
    end
    TaskSvc --> FFMate
    PresetSvc --> FFMate
    WatchfolderSvc --> FFMate
    WebhookSvc --> FFMate
    FFMate --> DB

    %% â”€â”€â”€ ffmpeg binary in dashed box â”€â”€â”€â”€â”€
    subgraph FFmpegBlock [" "]
        direction LR
        FFmpeg["ffmpeg Binary"]:::ffbin
    end
    style FFmpegBlock stroke-dasharray:5 5,stroke:#555,fill:none
    FFMate --> FFmpeg

    %% â”€â”€â”€ Stronger colour palette + black text â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    classDef ui     fill:#99d6ff,stroke:#2060a0,stroke-width:1.2px,color:#000000;
    classDef api    fill:#b3e0ff,stroke:#2060a0,stroke-width:1.2px,color:#000000;
    classDef svc    fill:#bdb4ff,stroke:#4b44a0,stroke-width:1.2px,color:#000000;
    classDef core   fill:#99ff99,stroke:#2d7a2d,stroke-width:1.2px,color:#000000;
    classDef db     fill:#ffcc80,stroke:#b36b00,stroke-width:1.2px,color:#000000;
    classDef ffbin  fill:#ff99cc,stroke:#b3366b,stroke-width:1.2px,color:#000000;
```

### 1. REST API

The REST API, is the primary way external clients (including the `FFmate` Web UI, scripts, or other services) interact with and control `FFmate`.

* **Functionality:** Provides endpoints for CRUD (Create, Read, Update, Delete) operations on:
  * Tasks (e.g., create single/batch, list, get status, cancel, restart, delete)
  * Presets
  * Watchfolders
  * Webhooks

### 2. SQLite Database

`FFmate` uses SQLite as its backend database to store all persistent data.

* **Data Stored:**
  * Tasks: All details about transcoding jobs, including their status, progress, input/output files, commands, priority, pre/post-processing info, timestamps, and any errors.
  * Presets: Definitions for reusable transcoding templates.
  * Webhooks: Configurations for URLs to be notified on specific events.
  * Watchfolders: Settings for monitored directories, including paths, intervals, associated presets, and filters.

### 3. Web UI

`FFmate` includes a modern web-based user interface for managing and monitoring tasks, presets, watchfolders, and webhooks.

* **Access:** When `ffmate` server starts, the web ui is served from the `/ui` path (e.g., `http://localhost:3000/ui`)
* **Backend Communication:** The Web UI communicates with the `ffmate` service via:
  * `REST API`: For actions like creating tasks, fetching lists, deleting presets, etc.
  * `WebSockets`: For receiving real-time updates like task progress, new log messages, and status changes.

### 5. Webhooks

Webhooks allow `FFmate` to automatically notify external systems about specific events by sending HTTP POST requests to configured URLs.

* **Configuration:**
  * Users define webhooks via the `REST API` (`/api/v1/webhooks`).
  * Each webhook configuration includes:
    * **Event (`event`):** The specific `ffmate` event that will trigger this webhook (e.g., `task.created`, `task.updated`, `batch.finished`, `preset.deleted`).
    * **URL (`url`):** The external HTTP(S) endpoint to which `ffmate` will send the notification.
* **Triggering:** When a configured event occurs within `FFmate`:
  * `FFmate` automatically sends an HTTP POST request.
  * This request is sent to the `URL` defined in the webhook configuration.
  * The body of the request contains a JSON payload detailing the `event` that occurred and relevant `data` associated with it.
* **Payload Structure:**
  ```json
  {
    "event": "event.name.here",
    "data": { ... }
  }
  ```

### 6. Watchfolder

The Watchfolder feature allows `FFmate` to monitor directories for new files and automatically create transcoding tasks for them based on a specified preset.

* **Configuration:** Watchfolders are configured via the `REST API` or `Web UI`. Each configuration includes:
  * **Path (`path`):** The directory to monitor.
  * **Preset (`preset`):** The name of the preset to apply to newly detected files.
  * **Interval (`interval`):** How often the directory is scanned (e.g., `10s`).
  * **Filters (`filters`):** (Optional) Rules to include or exclude specific files (e.g., by extension).
  * **Growth Checks (`growthChecks`):** (Optional) How many scan intervals a file must remain stable in size before being processed.
* **Monitoring Process:**
  * `FFmate` starts monitoring configured directories upon startup or configuration changes.
  * Directories are scanned periodically based on the configured `interval`.
  * New files are detected.
  * Files are checked for stability (size consistency) based on `growthChecks` to ensure they are fully written.
  * Configured `filters` are applied to the relevant files.
  * A new task is automatically created for each stable, filtered file.
  * The `preset` is applied to the new task.
  * `FFmate` keeps track of processed files to avoid creating duplicate tasks.
* **Dynamic Updates:** Changes to Watchfolder configurations (creation, updates, deletion) via the API or UI are dynamically loaded and applied without needing a `FFmate` restart.

### 7. Task Queue and `ffmpeg` Execution

This is the core process where your transcoding jobs are managed and processed from submission to completion.

* **Queueing:**
  * New tasks (submitted via `API`, `Web UI`, or `Watchfolders`) are added to a queue.
  * Tasks are processed based on their **Priority** (higher priority first) and then by creation time.
  * Initially, tasks are in the `QUEUED` status.
* **Concurrency Control:**
  * `FFmate` limits the number of tasks running simultaneously.
  * This limit is controlled by the `--max-concurrent-tasks` server setting.
  * When a slot becomes available, the next task from the queue starts processing.
* **Task Lifecycle:** Once a task is selected from the queue:
  * Its status is updated to `RUNNING`.
  * **Pre-processing:** If a pre-processing script is defined, it is executed before `ffmpeg`.
  * **`ffmpeg` Execution:** The primary transcoding command (`ffmpeg`) is executed.
  * **Progress Monitoring:** `FFmate` monitors `ffmpeg`'s output to track progress (e.g., percentage complete, time remaining). This progress is updated in the database and pushed via `WebSockets`.
  * **Post-processing:** If a post-processing script is defined and `ffmpeg` completed successfully, the post-processing script is executed.
  * **Completion:** The task status is updated to reflect the outcome: `DONE_SUCCESSFUL`, `DONE_ERROR`, or `DONE_CANCELED`. Error details are captured if applicable.
* **Notifications:** Throughout a task's lifecycle, status changes and progress updates are broadcast via `WebSockets` (used by the `Web UI`) and can trigger configured `Webhooks`.

These descriptions and diagrams should give users a clearer picture of the main data flows and component interactions within `ffmate`.

---

---
url: /README.md
---
# ffmate-docs

---

---
url: /markdown-examples.md
---
# Markdown Extension Examples

This page demonstrates some of the built-in markdown extensions provided by VitePress.

## Syntax Highlighting

VitePress provides Syntax Highlighting powered by [Shiki](https://github.com/shikijs/shiki), with additional features like line-highlighting:

**Input**

````md
```js{4}
export default {
  data () {
    return {
      msg: 'Highlighted!'
    }
  }
}
```
````

**Output**

```js{4}
export default {
  data () {
    return {
      msg: 'Highlighted!'
    }
  }
}
```

## Custom Containers

**Input**

```md
::: info
This is an info box.
:::

::: tip
This is a tip.
:::

::: warning
This is a warning.
:::

::: danger
This is a dangerous warning.
:::

::: details
This is a details block.
:::
```

**Output**

::: info
This is an info box.
:::

::: tip
This is a tip.
:::

::: warning
This is a warning.
:::

::: danger
This is a dangerous warning.
:::

::: details
This is a details block.
:::

## More

Check out the documentation for the [full list of markdown extensions](https://vitepress.dev/guide/markdown).

---

---
url: /docs/pre-post-prcessing.md
---
# Pre and Post-Processing

`FFmate` allows you to extend the functionality of your transcoding tasks by executing custom scripts *before* the `ffmpeg` command starts (pre-processing) and *after* it successfully completes (post-processing). This powerful feature enables you to automate a wide range of activities, from input validation and file preparation to notifications, archiving, and integration with other systems.

You can define pre and post-processing steps either directly within a task creation request or as part of a [Preset](#presets). If defined in both, the task-specific definition will take precedence.

### Configuration Parameters

For both pre-processing and post-processing, you can configure the following:

1. **`scriptPath`**:
   * **Purpose**: Defines the command or the full path to the script you want `ffmate` to execute.
   * **Wildcards**: This field fully supports `ffmate`'s [Wildcards](#wildcards). This means you can dynamically pass filenames, dates, UUIDs, and other task-related information as arguments to your script.
   * **Execution**: `ffmate` will attempt to execute this string as a command. Ensure your script is executable and its path is correct. The script will run with the same environment and permissions as the `ffmate` process itself.
   * **Exit Codes**:
     * A **zero exit code** (0) from your script indicates success.
     * A **non-zero exit code** indicates an error.
       * If a *pre-processing* script exits with a non-zero code, the main `ffmpeg` task will **not** run, and the entire task will be marked as failed.
       * If a *post-processing* script exits with a non-zero code, the main `ffmpeg` task has already completed successfully, but the overall `ffmate` task will be marked as failed due to the post-processing error.
   * *Example*: `python3 /opt/ffmate_scripts/prepare_audio.py --input ${INPUT_FILE} --normalize-level -3dBFS`

2. **`sidecarPath`**:
   * **Purpose**: (Optional) Specifies a path where `ffmate` will write a JSON file containing detailed information about the current task. Your script can then read this "sidecar" file to get context.
   * **Wildcards**: This field also supports [Wildcards](#wildcards), allowing you to name and place the sidecar file dynamically.
   * **Content**: The sidecar JSON file contains a snapshot of the `ffmate` task object at that point in the workflow.
     * For **pre-processing**, this includes the raw and (potentially partially) resolved input/output paths, any metadata you provided with the task, task UUID, name, priority, etc.
     * For **post-processing**, this includes all the above, plus the *final resolved* output path from `ffmpeg`, and the task's status will typically be `RUNNING` (just before it's marked `DONE_SUCCESSFUL` if post-processing also succeeds).
   * *Example*: `${INPUT_FILE_DIR}/${INPUT_FILE_BASENAME}.task_info.json`

### Workflow

1. **Task Queued:** A new task is created (either directly or via a watchfolder).
2. **Pre-Processing (if defined):**
   * `ffmate` resolves wildcards in `preProcessing.sidecarPath` (if defined) and writes the task data JSON file.
   * `ffmate` resolves wildcards in `preProcessing.scriptPath`.
   * `ffmate` executes the `scriptPath` command.
   * If the script fails (non-zero exit code), the task status is set to `DONE_ERROR`, and the process stops here. The error from the script is logged.
3. **FFmpeg Processing:**
   * If pre-processing was successful (or not defined), `ffmate` resolves wildcards for the main `ffmpeg` command, input, and output files.
   * The `ffmpeg` command is executed.
   * If `ffmpeg` fails, the task status is set to `DONE_ERROR`, and the process stops here. Post-processing will not run.
4. **Post-Processing (if defined):**
   * Assuming `ffmpeg` completed successfully, `ffmate` resolves wildcards in `postProcessing.sidecarPath` (if defined) and writes/updates the task data JSON file (now including the final `ffmpeg` output path).
   * `ffmate` resolves wildcards in `postProcessing.scriptPath`.
   * `ffmate` executes the `scriptPath` command.
   * If the script fails (non-zero exit code), the task status is set to `DONE_ERROR`. The error from the script is logged.
5. **Task Completion:**
   * If post-processing was successful (or not defined), the task status is set to `DONE_SUCCESSFUL`.

### Practical Examples

#### Example 1: Pre-Processing - Input Validation and Metadata Extraction

* **Goal**: Before transcoding, ensure the input video is not too short and extract its duration into the task's metadata for potential use by `ffmpeg` or post-processing.
* **Preset/Task Configuration:**

  ```json
  {
    "preProcessing": {
      "scriptPath": "python /opt/ffmate_scripts/validate_and_get_duration.py --sidecar ${INPUT_FILE_DIR}/${INPUT_FILE_BASENAME}.pre_task_info.json",
      "sidecarPath": "${INPUT_FILE_DIR}/${INPUT_FILE_BASENAME}.pre_task_info.json"
    }
    // ... other preset/task details
  }
  ```

#### Example 2: Post-Processing - Upload to Cloud Storage and Notify

* **Goal**: After a successful transcode, upload the output file to an S3 bucket and send a Slack notification.
* **Preset/Task Configuration:**

  ```json
  {
    "postProcessing": {
      "scriptPath": "/opt/ffmate_scripts/upload_and_notify.sh",
      "sidecarPath": "${OUTPUT_FILE_DIR}/${OUTPUT_FILE_BASENAME}.post_task_info.json"
    }
    // ... other preset/task details
  }
  ```
* **`upload_and_notify.sh` (Conceptual):**

  ```bash
  #!/bin/bash
  set -e # Exit immediately if a command exits with a non-zero status.

  SIDECAR_FILE=""

  # Basic argument parsing (robust scripts would use getopts)
  if [ "$1" == "--sidecar" ] && [ -n "$2" ]; then
      SIDECAR_FILE="$2"
  else
      # If ffmate passes sidecar path as the first arg directly
      SIDECAR_FILE="$1" 
  fi


  if [ -z "$SIDECAR_FILE" ] || [ ! -f "$SIDECAR_FILE" ]; then
      echo "Error: Sidecar file path not provided or file not found." >&2
      exit 1
  fi

  # Read data from sidecar using 'jq' (JSON processor)
  OUTPUT_FILE=$(jq -r '.outputFile.resolved' "$SIDECAR_FILE")
  TASK_NAME=$(jq -r '.name // "Untitled Task"' "$SIDECAR_FILE")
  TASK_UUID=$(jq -r '.uuid' "$SIDECAR_FILE")

  if [ -z "$OUTPUT_FILE" ]; then
      echo "Error: Could not extract output file from sidecar." >&2
      exit 1
  fi

  S3_BUCKET="s3://my-ffmate-outputs"
  SLACK_WEBHOOK_URL="https://hooks.slack.com/services/YOUR/SLACK/WEBHOOK"

  echo "Uploading ${OUTPUT_FILE} to ${S3_BUCKET}..."
  aws s3 cp "${OUTPUT_FILE}" "${S3_BUCKET}/"
  if [ $? -ne 0 ]; then
      echo "Error: S3 upload failed for ${OUTPUT_FILE}." >&2
      exit 2
  fi
  echo "Upload successful."

  # Send Slack notification
  MESSAGE_TEXT="Task Complete: '${TASK_NAME}' (UUID: ${TASK_UUID}). Output: ${S3_BUCKET}/$(basename "${OUTPUT_FILE}")"
  PAYLOAD="{\"text\": \"${MESSAGE_TEXT}\"}"

  curl -X POST -H 'Content-type: application/json' --data "${PAYLOAD}" "${SLACK_WEBHOOK_URL}"
  if [ $? -ne 0 ]; then
      echo "Warning: Slack notification failed, but file was uploaded." >&2
      # Decide if this should be a hard fail (exit 3) or just a warning
  fi

  echo "Post-processing complete for ${TASK_UUID}."
  exit 0 # Success
  ```

---

---
url: /docs/presets.md
---
# Presets

Presets in `ffmate` are powerful templates that allow you to pre-configure common `ffmpeg` operations. They help you save time, ensure consistency, and simplify the process of creating new transcoding tasks.

Think of a preset as a named, reusable recipe for a specific type of video or audio conversion.

### What Can You Define in a Preset?

When you create a preset, you can specify several key parameters that will be automatically applied to tasks created using that preset:

1. **Name (`name`):**
   * A unique, human-readable name for your preset (e.g., "Convert to MP4 1080p", "Extract Audio as MP3"). This helps you easily identify and select it.

2. **Description (`description`):**
   * (Optional) A more detailed explanation of what the preset does or any specific notes about its usage.

3. **FFmpeg Command (`command`):**
   * The core `ffmpeg` command string you want to execute. This is where you define codecs, bitrates, resolutions, filters, etc.
   * You can use `ffmate`'s [Wildcards](#wildcards) (like `${INPUT_FILE}` and `${OUTPUT_FILE}`) within the command. `ffmate` will replace these with the actual file paths when a task is processed.
   * **Important:** When a task uses a preset, the `command` from the preset will *always* be used, overriding any command specified directly in the task creation request.

4. **Output File Pattern (`outputFile`):**
   * A pattern for generating the output filename. This also supports [Wildcards](#wildcards) to create dynamic and organized output filenames (e.g., `${INPUT_FILE_BASENAME}_1080p.mp4`).
   * If you specify an `outputFile` directly when creating a task, that will take precedence over the preset's `outputFile`. If you don't, the preset's pattern will be used.

5. **Priority (`priority`):**
   * A numerical value indicating the priority of tasks created with this preset in the processing queue.
   * **Higher numbers mean higher priority.** For example, a task with priority `100` will be processed before a task with priority `10`.
   * If multiple tasks have the same priority, they are generally processed in the order they were created (First-In, First-Out for that priority level).
   * If you specify a `priority` directly when creating a task, that will take precedence. Otherwise, the preset's priority is used. If neither is set, a default priority (likely 0) will be used.

6. **Pre-Processing (`preProcessing`):**
   * (Optional) Configure a script to run *before* the main `ffmpeg` command.
   * **`scriptPath`**: The command or path to the script to execute. Wildcards can be used here.
     * *Example*: `python /opt/scripts/validate_input.py --input ${INPUT_FILE} --metadata_out ${INPUT_FILE_BASENAME}.json`
   * **`sidecarPath`**: (Optional) Path where `ffmate` will write a JSON file containing the task's details (metadata, input/output paths) *before* running the pre-processing script. Your script can then read this file. Wildcards can be used here.
     * *Example*: `${INPUT_FILE_DIR}/${INPUT_FILE_BASENAME}_ffmate_task.json`
     * *Use Case*: Your `validate_input.py` script could read this sidecar file to get the original input filename, user-provided metadata, and then perform checks like ensuring the file exists or meets certain duration criteria. If validation fails, the script can exit with an error code, which will cause `ffmate` to mark the pre-processing step (and thus the task) as failed.
   * If you define `preProcessing` directly in a task creation request, it will be used. Otherwise, the preset's `preProcessing` configuration (if any) will be applied.

7. **Post-Processing (`postProcessing`):**
   * (Optional) Configure a script to run *after* the `ffmpeg` command completes successfully.
   * **`scriptPath`**: The command or path to the script to execute. Wildcards can be used here.
     * *Example*: `bash /opt/scripts/archive_and_notify.sh --source ${OUTPUT_FILE} --original ${INPUT_FILE}`
   * **`sidecarPath`**: (Optional) Path where `ffmate` will write a JSON file containing the task's details (including the final output path from `ffmpeg`) *before* running the post-processing script. Wildcards can be used here.
     * *Example*: `${OUTPUT_FILE_DIR}/${OUTPUT_FILE_BASENAME}_ffmate_task_complete.json`
     * *Use Case*: Your `archive_and_notify.sh` script could read the sidecar to get the final output filename. It might then move `${OUTPUT_FILE}` to a long-term archive, send an email notification with the file details, and optionally delete `${INPUT_FILE}` if it's no longer needed.
   * If you define `postProcessing` directly in a task creation request, it will be used. Otherwise, the preset's `postProcessing` configuration (if any) will be applied.

### How to Manage Presets

You can manage presets through `ffmate`'s:

* **REST API:**
  * `POST /api/v1/presets`: Create a new preset.
  * `GET /api/v1/presets`: List all existing presets.
  * `DELETE /api/v1/presets/{uuid}`: Delete a preset by its unique ID.
* **Web UI:** The `ffmate` web interface provides a user-friendly way to create, view, and delete presets.

**Example: Creating a Preset via API with Contextualized Post-Processing**

```json
// POST /api/v1/presets
{
  "name": "ProRes HQ for Archive",
  "description": "Converts input to ProRes HQ and moves it to the archive.",
  "command": "ffmpeg -i ${INPUT_FILE} -c:v prores_ks -profile:v 3 -vendor apl0 -bits_per_mb 8000 -pix_fmt yuv422p10le -c:a pcm_s16le ${OUTPUT_FILE}",
  "outputFile": "${INPUT_FILE_BASENAME}_prores_hq.mov",
  "priority": 50,
  "postProcessing": {
    "scriptPath": "/usr/local/bin/move_to_archive.sh --file ${OUTPUT_FILE} --project-id some_project_id_from_metadata",
    "sidecarPath": "${OUTPUT_FILE_DIR}/${OUTPUT_FILE_BASENAME}.json"
  }
}
```

*(In this example, `move_to_archive.sh` would be a custom script. The `project-id` could be something passed in the task's `metadata` field and then potentially extracted from the sidecar JSON by the script, though the example script path directly includes a placeholder for simplicity here. A more robust script would parse the sidecar for such dynamic values.)*

### How to Use Presets When Creating Tasks

When you create a new task, you can simply reference the `uuid` of an existing preset.

**Example: Creating a Task using a Preset via API**

```json
// POST /api/v1/tasks
{
  "name": "Archive Raw Footage",
  "inputFile": "/path/to/raw_footage_01.mxf",
  "preset": "uuid-of-ProRes-HQ-for-Archive-preset", // Replace with actual preset UUID
  "metadata": {
    "project-id": "project_alpha_123",
    "shot_number": "005"
  }
}
```

`ffmate` will then automatically:

1. Use the `command` from the "ProRes HQ for Archive" preset.
2. Generate the output path using the preset's `outputFile` pattern.
3. Apply the preset's `priority` (50).
4. After successful `ffmpeg` processing, it will create the sidecar file (e.g., `/path/to/raw_footage_01_prores_hq.json` containing task details) and then execute the `postProcessing` script (`/usr/local/bin/move_to_archive.sh ...`).

---

---
url: /api-examples.md
---

# Runtime API Examples

This page demonstrates usage of some of the runtime APIs provided by VitePress.

The main `useData()` API can be used to access site, theme, and page data for the current page. It works in both `.md` and `.vue` files:

```md
<script setup>
import { useData } from 'vitepress'

const { theme, page, frontmatter } = useData()
</script>

## Results

### Theme Data
<pre>{{ theme }}</pre>

### Page Data
<pre>{{ page }}</pre>

### Page Frontmatter
<pre>{{ frontmatter }}</pre>
```

## Results

### Theme Data

### Page Data

### Page Frontmatter

## More

Check out the documentation for the [full list of runtime APIs](https://vitepress.dev/reference/runtime-api#usedata).

---

---
url: /docs/tasks.md
---
# Understanding Tasks in FFmate

In FFmate, a **task** is an individual FFmpeg job, whether it's transcoding, extracting audio, or applying filters. Tasks can be submitted **individually** or as part of a **batch**, allowing multiple files to be processed efficiently in a single request. Every task follows a structured **lifecycle**, progressing from submission to execution and ultimately reaching completion or failure.

Before diving into task execution, let's first go through the **lifecycle** of tasks and their corresponding **statuses** in FFmate.

| Status       | Description                                         |
|-------------|-----------------------------------------------------|
| `queued`     | The task is waiting to be processed.               |
| `processing` | The task is currently being executed by FFmpeg.   |
| `completed`  | The task has finished successfully.               |
| `failed`     | The task encountered an error during execution.   |
| `canceled`   | The task was manually canceled before completion. |

### Task Flow:

The diagram below shows how a task progresses through its lifecycle in FFmate

```mermaid
graph TD;
    queued -->|Starts processing| processing;
    processing -->|Finishes successfully| completed;
    processing -->|Fails| failed;
    queued -->|Canceled| canceled;
```

Next, let's explore how to trigger and manage single tasks in FFmate

## Creating a Task

To create a task, send a `POST` request to the FFmate API:

```sh
curl -X POST http://localhost:3000/api/v1/tasks \
     -H "Content-Type: application/json" \
     -d '{
       "command": "-y -i ${INPUT_FILE} -c:v libx264 -preset fast -crf 23 ${OUTPUT_FILE}",
       "inputFile": "videos/input.mp4",
       "outputFile": "videos/output.mp4",
       "priority": 2
     }'
```

### Task Properties

* **`command`** *\[mandatory]*

Defines the FFmpeg command to execute. FFmate **implicitly calls the FFmpeg binary**, so you only need to specify the **command-line parameters and flags**, without including `ffmpeg` itself.

* **`inputFile`** *\[optional]* â€“ The path to the input media file that will be processed..

* **`outputFile`** *\[optional]* â€“ The path where the transcoded file should be saved.

::: tip Handling Input and Output Files

* The **`inputFile`** and **`outputFile`** properties are **optional** and should only be used if your command includes the placeholders `${INPUT_FILE}` and `${OUTPUT_FILE}`.

* FFmate **automatically replaces** these placeholders with the actual file paths during execution.

* If your command **directly specifies input and output paths**, you do **not** need to provide these properties separately.
  :::

* **`priority`** *\[mandatory]* â€“ Determines the execution order:
  * `1` â†’ Low priority
  * `2` â†’ Normal priority (default)
  * `3` â†’ High priority
  * `4` â†’ Critical priority (executed first)

After submitting a task, FFmate will respond with a JSON object containing the `taskId`. This `taskId` can be used to monitor the taskâ€™s progress in the next section.

## Monitoring a Task

Once submitted, you can check a taskâ€™s status by making a `GET` request:

```sh
curl -X 'GET' \
  'http://localhost:3000/api/v1/tasks/{taskId}' \
  -H 'accept: application/json'
```

Replace `{taskId}` with the actual task ID from the submission response.

## Monitoring All Tasks

FFmate allows you to retrieve a list of all tasks, regardless of their current stateâ€”whether they are waiting in the queue, actively processing, successfully completed, or encountered an error.

To retrieve a list of all tasks, send a GET request to the API:

```sh
curl -X 'GET' \
  'http://localhost:3000/api/v1/tasks?page=0&perPage=100' \
  -H 'accept: application/json'
```

**Query Parameters:**

* **`page`** *\[optional]* â€“ Specifies which page of results to retrieve. Default: `0`.
* **`perPage`** *\[optional]* â€“ Defines how many tasks should be included in each page. Default: `100`.

## Canceling a Task

FFmate allows you to cancel a task that is currently **queued** or **processing**. Once canceled, the task will not be executed or will be stopped if already in progress.

To cancel a task, make a `PATCH` request:

```sh
curl -X 'PATCH' \
  'http://localhost:3000/api/v1/tasks/{taskId}/cancel' \
  -H 'accept: application/json'
```

**Query Parameters:**

* **`{taskId}`** *\[mandatory]* â€“ Specifies unique ID of the task you want to cancel.

> \[!NOTE]
> If the task is already processing, FFmate will attempt to **stop** it, but cancellation may not always be immediate.

## Restarting a Task

If a task has failed or been canceled, FFmate allows you to restart it without needing to resubmit the job manually.

To restart a task, send a `PATCH` request:

```sh
curl -X 'PATCH' \
  'http://localhost:3000/api/v1/tasks/{taskId}/restart' \
  -H 'accept: application/json'
```

**Query Parameters:**

* **`{taskId}`** *\[mandatory]* â€“ The unique identifier of the task to restart.

> \[!TIP]
>
> * Restarting a task will **re-run the exact same command** using the original input and output paths.
> * If the task was previously processing, it will start from the beginning.

Once restarted, the task will move back into the **queued** state and follow the standard task lifecycle.

## Deleting a Task

Once a task is completed, canceled, or no longer needed, you can **permanently remove** it from FFmate.

To delete a task, make a `DELETE` request:

```sh
curl -X 'DELETE' \
  'http://localhost:3000/api/v1/tasks/{taskId}' \
  -H 'accept: application/json'
```

**Query Parameters:**

* **`{taskId}`** *(mandatory)* â€“ The unique ID of the task to be deleted.

::: warning Important

* Deleting a task **removes the database entry** from FFmate but **does not** delete the input or output files.
* If the task is still processing, FFmate will attempt to **stop** it before deletion.
  :::

Okay, let's document how Batch Operations work in `ffmate`.

## Batch Operations: Processing Multiple Tasks Efficiently

`ffmate` allows you to submit multiple transcoding tasks in a single request, known as a "batch." This is particularly useful when you have a collection of files to process with similar (or different) settings, as it streamlines the submission process and helps `ffmate` manage them as a related group.

### What is a Batch?

When you submit multiple task definitions in one API call, `ffmate` assigns a unique **Batch ID** (a UUID) to all tasks created from that submission. This Batch ID serves as a common identifier for the group.

* **Individual Tasks:** Each item in your batch request still becomes an individual task within `ffmate`. This means each task will:
  * Go through its own lifecycle (Queued, Pre-Processing, Running, Post-Processing, Done).
  * Be processed independently by `ffmpeg` according to its specific settings (or preset).
  * Have its own progress, status, and potential errors.
* **No Inter-Task Dependency (by default):** `ffmate` processes tasks in a batch concurrently (up to the `max-concurrent-tasks` limit) or sequentially based on their priority and queue order. The success or failure of one task in a batch does not inherently affect other tasks *within the same batch* unless you implement such logic in your pre/post-processing scripts.

### How to Submit a Batch of Tasks

You submit a batch of tasks using the REST API by sending a `POST` request to the `/api/v1/tasks/batch` endpoint. The request body should be a JSON array, where each element in the array is a standard `NewTask` object (the same object you'd use for creating a single task via `/api/v1/tasks`).

**API Endpoint:** `POST /api/v1/tasks/batch`

**Request Body:** An array of `NewTask` objects.

**Example: Submitting a Batch of Two Tasks**

```json
// POST /api/v1/tasks/batch
[
  {
    "name": "Convert Episode 1 to WebM",
    "inputFile": "/mnt/source_videos/seriesA/episode_01.mov",
    "preset": "uuid-of-webm-720p-preset", // Reference a preset
    "priority": 20
  },
  {
    "name": "Convert Episode 2 to WebM",
    "inputFile": "/mnt/source_videos/seriesA/episode_02.mov",
    "preset": "uuid-of-webm-720p-preset",
    "priority": 20
  },
  {
    "name": "Extract Thumbnail for Promo Image",
    "command": "ffmpeg -ss 00:01:30 -i ${INPUT_FILE} -frames:v 1 -q:v 2 ${OUTPUT_FILE}",
    "inputFile": "/mnt/source_videos/seriesA/promo_material.mp4",
    "outputFile": "/mnt/output_images/promo_thumbnail_${TIMESTAMP_SECONDS}.jpg",
    "priority": 50
  }
]
```

**Response:**

Upon successful submission, `ffmate` will respond with a JSON array containing the full `Task` objects for each task created in the batch. Each of these task objects will include the same `batch` ID.

```json
// 200 OK
[
  {
    "uuid": "task-uuid-1",
    "batch": "batch-uuid-for-this-submission", // Same for all tasks in this batch
    "name": "Convert Episode 1 to WebM",
    "status": "QUEUED",
    // ... other task details
  },
  {
    "uuid": "task-uuid-2",
    "batch": "batch-uuid-for-this-submission", // Same for all tasks in this batch
    "name": "Convert Episode 2 to WebM",
    "status": "QUEUED",
    // ... other task details
  },
  {
    "uuid": "task-uuid-3",
    "batch": "batch-uuid-for-this-submission", // Same for all tasks in this batch
    "name": "Extract Thumbnail for Promo Image",
    "status": "QUEUED",
    // ... other task details
  }
]
```

### Managing and Monitoring Batches

While `ffmate` treats each task in a batch individually for processing, the Batch ID allows you to group and monitor them:

1. **Listing Tasks by Batch ID:**
   * You can retrieve all tasks belonging to a specific batch using the API:
     `GET /api/v1/tasks/batch/{batch_uuid}`
   * This is useful for checking the overall progress of a submitted batch.

2. **Webhooks:**
   * **`batch.created`**: This webhook event (if configured) fires once when a batch of tasks is successfully submitted. The payload will typically be an array of the created task DTOs.
   * **`batch.finished`**: This webhook event fires when *all* tasks belonging to a specific Batch ID have reached a terminal state (e.g., `DONE_SUCCESSFUL`, `DONE_ERROR`, `DONE_CANCELED`).
     * The payload for this webhook would likely provide a summary or list of the final states of all tasks in that batch. This is ideal for triggering follow-up actions once an entire set of related jobs is complete.

### Use Cases for Batch Operations

* **Bulk Transcoding:** Processing an entire folder of videos to a new format or resolution.
* **Multi-Rendition Generation:** Creating multiple versions (e.g., different bitrates, resolutions) of the same source file. Each rendition would be a separate task in the batch.
* **Sequential Asset Processing:** Submitting tasks for different stages of a media workflow (e.g., Task 1: Clean audio, Task 2: Transcode video, Task 3: Watermark) for a set of source files. While `ffmate` processes them based on queue rules, you can monitor them as a batch.
* **Simplifying Client Submissions:** Clients interacting with your `ffmate` instance can submit multiple related jobs in a single API call, reducing network overhead and simplifying their logic.

### Considerations

* **Error Handling:** If the overall batch submission request is malformed (e.g., invalid JSON), the entire request will fail. However, if the JSON array is valid but one of the individual `NewTask` objects within it is invalid (e.g., missing a required field if not using a preset), `ffmate` *may* reject the entire batch or process the valid tasks and report errors for the invalid ones. Check the API response and `ffmate` logs for specific behavior.
* **Resource Management:** Submitting very large batches can quickly fill up the task queue. `ffmate`'s `max-concurrent-tasks` setting will prevent system overload, but tasks will remain queued, potentially for a long time. Plan your batch sizes accordingly.

Batch operations in `ffmate` provide a convenient way to manage groups of related transcoding jobs, improving workflow efficiency and enabling more complex automation scenarios, especially when combined with webhooks like `batch.finished`.

---

---
url: /index.md
---


---

---
url: /docs/web-ui.md
---


---

---
url: /docs/watchfolder.md
---
# Watchfolders

FFmate's **watchfolder** feature allows you to **automatically detect and process new files** in a specified directory. Once a watchfolder is configured, FFmate will **continuously scan** the folder for new or modified files and create **tasks** to process them based on a task preset. The watchfolder feature is useful for automatically transcoding footage from a camera SD card dropped into a network share or creating low-resolution versions of high-resolution files exported from an NLE for review.

## How Watchfolders Work:

1. **Monitor a Folder** â€“ FFmate scans the specified directory at a set interval.
2. **Detect New Files** â€“ When a new file is detected, FFmate ensures itâ€™s **fully copied** before processing.
3. **Create Tasks** â€“ FFmate creates a **new FFmate task** for each detected file.

## Creating a Watchfolder

To configure a watchfolder, send a `POST` request to the API:

```sh
curl -X POST http://localhost:3000/api/v1/watchfolders \
     -H "Content-Type: application/json" \
     -d '{
       "name": "Camera Card Watch",
       "description": "Automatically processes camera footage",
       "interval": 10,
       "growthChecks": 3,
       "preset": "cabfad2c-70d1-4df6-9267-f549a376301f",
       "path": "/volumes/media/camera_cards",
       "filter": {
         "extensions": {
           "include": ["mp4", "mov"],
           "exclude": ["tmp", "log"]
         }
       }
     }'
```

## Watchfolder Properties:

* **`name`** â€“ A unique name for the watchfolder.
* **`description`** â€“ Optional description of what this watchfolder does.
* **`interval`** â€“ How often (in seconds) FFmate scans the folder for new files.
* **`growthChecks`** â€“ The number of checks FFmate performs to ensure a file is fully copied before processing.
* **`preset`** â€“ The ID of a predefined transcoding **preset** that will be applied to detected files.
* **`path`** â€“ The **absolute path** of the directory to monitor.
* **`filter`** â€“ Rules for file selection:
  * **`include`** â€“ Only process files with these extensions (e.g., `mp4`, `mov`).
  * **`exclude`** â€“ Ignore files with these extensions (e.g., `tmp`, `log`).

## How File Detection Works:

FFmate ensures that only **fully copied** files are processed by using a **growth check validation**:

1. A file is detected in the watchfolder.
2. FFmate checks its **size**.
3. If the size remains the same after multiple scans (determined by `growthChecks`), the file is processed.
4. If the file is **still growing**, FFmate waits and continues checking until it stops changing.

This prevents **incomplete** files from being prematurely processed.

## Deleting a Watchfolder

To remove a watchfolder, send a `DELETE` request:

```sh
curl -X DELETE http://localhost:3000/api/v1/watchfolders/{watchfolderId} \
     -H "accept: application/json"
```

### List All Watchfolders

```sh
curl -X GET http://localhost:3000/api/v1/watchfolders
```

### Get Watchfolder Details

```sh
curl -X GET http://localhost:3000/api/v1/watchfolders/{watchfolderId}
```

### Update a Watchfolder

```sh
curl -X PATCH http://localhost:3000/api/v1/watchfolders/{watchfolderId} \
     -H "Content-Type: application/json" \
     -d '{
       "interval": 15,
       "filter": {
         "include": ["mp4", "avi"]
       }
     }'
```

---

---
url: /docs/webhooks.md
---
# Webhooks

FFmate supports **webhooks**, allowing external systems to receive **real-time notifications** when specific events occur. By registering a webhook, you can automatically trigger actions in response to changes in FFmate, such as task creation, status updates, batch processing, or preset modifications.

## Setting Up a Webhook

To configure a webhook, make a `POST` request to the API with the event you want to subscribe to and the URL where FFmate should send notifications.

```sh
curl -X POST http://localhost:3000/api/v1/webhooks \
     -H "Content-Type: application/json" \
     -d '{
       "event": "task.created",
       "url": "https://yourserver.com/webhook-handler"
     }'
```

### Webhook Payload:

When the specified event occurs, FFmate will send an HTTP `POST` request to the provided URL with relevant event data.

```json
{
  "event": "task.created",
  "timestamp": "2025-02-13T14:05:32Z",
  "data": {
    "taskId": "550e8400-e29b-41d4-a716-446655440000",
    "inputFile": "/source/video.mp4",
    "outputFile": "/destination/video_converted.mp4",
    "status": "queued"
  }
}
```

## Available Webhook Events

FFmate provides a variety of webhook events, grouped into different categories:

### Task Events:

| Event              | Description |
|--------------------|-------------|
| `task.created`    | Triggered when a new task is added. |
| `task.updated`    | Triggered when a task's status or details are updated. |
| `task.deleted`    | Triggered when a task is deleted. |

***

### Batch Events:

| Event              | Description |
|--------------------|-------------|
| `batch.created`   | Triggered when a new batch of tasks is created. |
| `batch.finished`  | Triggered when a batch of tasks is completed. |

***

### Preset Events:

| Event              | Description |
|--------------------|-------------|
| `preset.created`  | Triggered when a new preset is created. |
| `preset.updated`  | Triggered when an existing preset is modified. |
| `preset.deleted`  | Triggered when a preset is removed. |

***

### Watchfolder Events:

| Event                  | Description |
|------------------------|-------------|
| `watchfolder.created`  | Triggered when a new watchfolder is created. |
| `watchfolder.updated`  | Triggered when an existing watchfolder is modified. |
| `watchfolder.deleted`  | Triggered when a watchfolder is removed. |

***

### Webhook Events :

| Event              | Description |
|--------------------|-------------|
| `webhook.created` | Triggered when a new webhook is registered. |
| `webhook.deleted` | Triggered when a webhook is removed. |

## Deleting a Webhook

To remove a webhook, send a `DELETE` request with its ID:

```sh
curl -X DELETE http://localhost:3000/api/v1/webhooks/{webhookId} \
     -H "accept: application/json"
```

## Setting Up Your Webhook Endpoint

When FFmate sends a webhook, it expects your server to be ready to receive and respond to the event. Here's what your endpoint should do:

1. **Accept HTTP POST requests**

FFmate sends events using a `POST` request with a JSON payload.\
Your endpoint should be configured to accept and correctly parse these requests.

2. **Return a 200 OK response**

To confirm that the event was received successfully, your server **must** return an HTTP `200 OK` status.\
Any other status code may cause FFmate to assume the delivery failed.

3. **Log incoming requests**

FFmate **does not store webhook logs**.\
If something goes wrong, your application should log incoming webhook events to support debugging or auditing.

---

---
url: /docs/what-is-ffmate.md
---
# What is FFmate?

**FFmate is not just another media processing server, itâ€™s a powerful extension of FFmpeg that makes it more accessible, automated, and feature-rich.**

While FFmpeg is an incredible media toolkit, it lacks essential capabilities like queue management, a REST API, watchfolder monitoring, out-of-the-box presets, webhook notifications, and a user-friendly interface.

FFmate fills these gaps, bringing FFmpegâ€™s full power to developers, workflow engineers, and non-technical users alike.

## ðŸš€ Key Features

* **Queueing System** â€“ Submit and manage multiple concurrent FFmpeg jobs efficiently.
* **Dynamic Filename Wildcards** â€“ Enable smart and customizable output file naming.
* **Webhook Notifications** â€“ Receive real-time updates for seamless integration with external workflows.
* **Watchfolder** â€“ Automatically detect and process new files as they appear.
* **Pre & Post Processing Actions** â€“ Execute custom commands or scripts before and after transcoding.
* **Preconfigured Presets** â€“ Simplify common media conversion tasks with ready-to-use settings.
* **Web UI** â€“ Monitor and configure transcoding workflows with an intuitive interface.

## ðŸ“Œ Use Cases

### ðŸ“½ï¸ Automated media transcoding

Convert videos, extract audio, or generate thumbnails with minimal setup.

## âš™ï¸ Workflow & Pipeline automation

Webhooks provide real-time notifications for seamless integration with:

* **Internal pipeline tooling**
* **Media asset management systems**
* **Cloud workflows**

### â˜ï¸ Scalable FFmpeg API Backend

Deploy FFmate as a centralized transcoding service with intelligent job management.

***

### ðŸ—‚ï¸ Watchfolder

Drop media files into a **monitored folder**, and FFmate will automatically process them based on predefined rules.
